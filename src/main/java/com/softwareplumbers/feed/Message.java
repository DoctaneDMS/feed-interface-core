/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.softwareplumbers.feed;

import com.softwareplumbers.common.pipedstream.InputStreamSupplier;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.time.Instant;
import java.util.Objects;
import javax.json.JsonObject;

/** Simple interface for messages.
 * 
 * A message has two main parts - a set of Json 'headers' and a binary data 
 * stream. In addition it has a name (the 'FeedPath') and a timestamp. 
 *
 * @author jonathan
 */
public interface Message {
    
    /** Callback for handling errors when writing a message to a stream.
     * 
     * @param <T> Type of recovery object generated by error handler.
     */
    @FunctionalInterface
    public static interface ErrorHandler<T> {
        
        /** Recovery processing during write operation.
         * 
         * If the exception cannot be recovered it should be re-thrown by the
         * implementation.
         * 
         * @param e Exception being recovered from
         * @param is Stream that was retrieved from getData during the write operation
         * @return Any state generated by the recovery operation
         */
        public T recover(IOException e, InputStream is) throws IOException;
    }
    
    /** Get the headers of a message.
     * 
     * @return 
     */
    public JsonObject getHeaders();
    
    /** Get the binary data stream for a message 
     * 
     * @return 
     */
    public InputStream getData();
    public Message setData(InputStreamSupplier data, long length);
    
    /** Convert the message headers to a binary stream.
     * 
     * The returned stream has a Json part (which consists of the Json object
     * { name: *name*, timestamp: *timestamp*, headers: *headers*, length: *length* }
     * 
     * @return
     * @throws IOException 
     */
    public InputStream getHeaderStream() throws IOException;    
    
    public FeedPath getName();
    public long getLength();
    public Instant getTimestamp();
    public Message setTimestamp(Instant timestamp);   
    
    /** Get the id of the message.
     * 
     * Should be equivalent to getName().part.getId().
     * 
     * @return the id of the message.
     */
    public default String getId() {
        return getName().part.getId().orElseThrow(()->new RuntimeException("Invalid message id"));
    }
    
    /** Get the path of the feed to which the message was sent.
     * 
     * Should be equivalent to getName().beforeMessageId();
     * 
     * @return the id of the message.
     */
    public default FeedPath getFeedName() {
        return getName().beforeMessageId();
    }
    

    
    public void writeHeaders(OutputStream os) throws IOException;
    
    /** Write to output stream with optional error callback.
     * 
     * Writes data as defined in toStream() above.
     * 
     * A fairly standard function to write a message to an output stream, with one wrinkle -
     * because a message can be transient (i.e. have a data stream that can only be used once)
     * we need to be able to handle any errors before we close the InputStream we get back from
     * the getData method. Thus we have a callback which enables errors to be handled immediately.
     * 
     * @param <T> Output of errorCallback
     * @param os Output stream to write to
     * @param errorCallback error handler
     * @return result of error handler, or null if no error.
     * @throws IOException 
     */
    public <T> T writeData(OutputStream os, ErrorHandler<T> errorCallback) throws IOException;
    
    /** Write to a stream.
     * 
     * Writes data with no error handler.
     * 
     * @param os Output stream to write to
     * @throws IOException 
     */
    public default void writeData(OutputStream os) throws IOException {
        writeData(os, (e,is)->{ throw e; });
    }
    
    /** Compare messages.
     * 
     * Messages are equal if their name and headers are equal. Binary data is
     * note compared.
     * 
     * @param a Message a
     * @param b Message b
     * @return result of comparison.
     */
    public static boolean equals(Message a, Message b) {
        return Objects.equals(a.getName(), b.getName())
            && Objects.equals(a.getHeaders(), b.getHeaders());
    }
}

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.softwareplumbers.feed;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.time.Instant;
import java.util.Objects;
import javax.json.JsonObject;

/**
 *
 * @author jonathan
 */
public interface Message {
    
    /** Callback for handling errors when writing a message to a stream.
     * 
     * @param <T> 
     */
    @FunctionalInterface
    public static interface ErrorHandler<T> {
        
        /** Recovery processing during write operation.
         * 
         * If the exception cannot be recovered it should be re-thrown by the
         * implementation.
         * 
         * @param e Exception being recovered from
         * @param is Stream that was retrieved from getData during the write operation
         * @return Any state generated by the recovery operation
         */
        public T recover(IOException e, InputStream is) throws IOException;
    }
    
    public JsonObject getHeaders();
    public InputStream getData();
    public FeedPath getName();
    public Instant getTimestamp();
    public Message setTimestamp(Instant timestamp);    
    public default String getId() {
        return getName().part.getId().orElseThrow(()->new RuntimeException("Invalid message id"));
    }
    public default FeedPath getFeedName() {
        return getName().beforeMessageId();
    }
    public InputStream toStream() throws IOException;
    
    /** Write to output stream with optional error callback.
     * 
     * A fairly standard function to write a message to an output stream, with one wrinkle -
     * because a message can be transient (i.e. have a data stream that can only be used once)
     * we need to be able to handle any errors before we close the InputStream we get back from
     * the getData method. Thus we have a callback which enables errors to be handled immediately.
     * 
     * @param <T> Output of errorCallback
     * @param os Output stream to write to
     * @param errorCallback error handler
     * @return Optional result of error handler, or Optional.empty if no error.
     * @throws IOException 
     */
    public <T> T write(OutputStream os, ErrorHandler<T> errorCallback) throws IOException;
    
    public default void write(OutputStream os) throws IOException {
        write(os, (e,is)->{ throw e; });
    }
    
    
    public static boolean equals(Message a, Message b) {
        return Objects.equals(a.getName(), b.getName())
            && Objects.equals(a.getHeaders(), b.getHeaders());
    }
}
